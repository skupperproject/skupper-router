// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

:toc:
:toclevels: 5
= Skupper Router Architectural overview

== Brief history

Skupper router started its life in the Apache Qpid C++ broker project.
The Qpid C++ broker had a _broker federation_ feature to connect individual brokers and route messages between them.
This required manual provisioning of routes and was hard to scale and manage in a large deployment.
Lots of custom code required to make things work.

What router federation did was to create a network of interconnected brokers and run internet-like routing between them.
The messaging router idea is to let brokers be brokers and add a separate routing layer to connect them.

.First router commit
[source]
----
commit 438e7e82e17f008997276df528424a3cbb0bd32e
Author: Ted Ross <tross@apache.org>
Date:   Thu Oct 24 16:01:31 2013 +0000

	QPID-5257 - Add structure for the Dispatch sub-project
----

Since then, four developers over 8 years (as of 2022).

=== Broker federation

The primary use of router was _broker federation_.
That is, virtualization of brokers behind a routing messaging layer.
Router build many features to support these use-cases.

* Link Routes
* Autolinks
* Waypoints/Phases
* Policy/Vhosts
* Exchange/Bindings

All this still lives in the https://qpid.apache.org/components/dispatch-router[Qpid Dispatch Router] project.

=== Packet tunnelling (LanQP)

Virtual network interface can be created, that is then serving as entry point to the Router network.
On the user end, the interface is assigned an IP address and behaves as a regular network card.
The backed encapsulates the data into AMQP frames and sends them to the router network, which then delivers the data to correct interface on the other end.

This scenario is now much better handled by the Skupper.io (see below).
Old LanQP project (GNU GPL 2+) is at ted-ross/lanqp[https://github.com/ted-ross/lanqp].

=== Interconnected cloud

Cloud gave rise to a new paradigm of application architecture.
Microservices: multiple services implementing an aggregate functionality, each service communicates with some other services.
This provides for new use-cases for the router, but also requires new features.

Non-AMQP protocol support (HTTP, HTTPS, TCP) is required to support cloud applications.
On the whole, this add adds a different set of goals from broker integration.

Early version of this idea still lives as the https://github.com/interconnectedcloud[Interconnected cloud].

=== Skupper.io

Divergent use-cases imply divergent goals.
A car that flies is unlikely to be a good road car.
Therefore, the skupper router removes the advanced AMQP broker integration features and puts emphasis on the application networking use case.
Specifically, this means multi-protocol support with focus on non-AMQP protocols.

=== Legacy

After going through all these evolutions, the codebase has been marked by each and carries the marks to this day.
There is vestigial code as current implementations are influenced by deprecated and already removed features.
Opportunities for improvements can be found with a pair of fresh eyes.

== Architecture

=== Code organization

Codebase was initially split between qpid-dispatch library (`libqpid-dispatch.so`) and a qpid-dispatch-router binary (`qdrouterd`).

The library was designed as a generic infrastructure library for building high performance AMQP 1.0 server applications on top of Qpid Proton.
It provided implementations of container, links, connections, messages, etc.
There never were any users of the library besides the dispatch router binary, and eventually the library was partially folded into the router binary.

The dispatch library is no more but the current code structure is heavily influenced by it.

==== File layout

TODO see below

=== Proactor event loop

At the heart of the router lays the proactor event loop, provided by libqpid-proton-proactor library.
Every *worker thread* in the router runs the proactor event loop, and responds to events the loop returns.
Proactor events can be split into three groups: TODO.

In order to manipulate shared data, later in the development, a *core thread* has been dedicated to managing shared state.
The worker threads submit actions to a queue, from which the core thread consumes and performs the actions one by one, in a serialized manner.

There is a single core thread and one or more worker threads in the router.
In addition, the libwebsockets event loop runs in its own thread (TODO?) and there are timer thread(s? TODO).

(TODO lousy picture, this needs embedded svg because mermaid just does not seem to have the right diagram type for this.)

```mermaid
graph LR;
  subgraph Router core thread;
    M([$management]);
    DB[(Route Table)];
    As[Actions];
  end;
  subgraph Proactor;
    W1["Worker thread <br> (connection)"];
    W2["Worker thread <br> (timer)"];
    W3["Worker thread <br> (connection)"];
    W4["Worker thread <br> (connection)"];
  end;
  W1 --> As;
  DB --> W3;
  DB --> W4;
```

== Git repository layout

The router is a C project with embedded CPython.
There is a lot of Python code, but majority of it is auxiliary, for system-test stuff for CI.

* decisions/
**
* docs/notes
** internal documentation for developers, coding guidelines
** routing table, allocation tool; please document
* etc/
** "eci", config files
** config format, important, next meeting
*share
** one sad index.html
*tools/
** skstat (show high level information), skmanage (lower level CRUD operations on objects), scraper
* scraper (developer tool for AMQP log traffic analysis)

*scripts/ bin/
** difference unclear, utilities

* tests
** lots of tests, mostly python, unittests in c, some in C++

*python
** python/skupper_router
*** skrouter.json, management schema; great topic for docs
** python/skupper_router_internal
*** management subsystem, routing protocol implementation; part of management moved to C for speed
running in the core thread, so that due to core thread locking; if C core cannot handle it, it delegates to python

Python code implelents control plane
data paths miss python
but the routing is part c (mobile address processing) and part python
recompute paths and update routing tables

router/src/main.c, main deamon setup todo: signal setter func
because qpid dispatch "broker" idea
include/qpid/dispatch

* include/qpid/dispatch
** not installed, intially intended for public consumption (the library)

suggestion: move all files under include/

what is mechanism for module split?

* src/
** adaptors/

how decide if header goes to include or src?
private, then in src/

policy.h and policy_internal.h

document _LH and _CT


start with the Core API

maintaining forwarding data structures
unusual design, both operate quickly and also be able to efficiently reflect change

router_core.h
// routing tables section, line 86
interface between routing and data planes

core does one thing only, sequentially, all serialized
so all routing decisions are sent to the core thread to decide?

justin: high throughput for amqp, scheduling work between ingress, core and egress, small batches for proton which are inefficient
batches 20-100 messages

streaming message: core not involved after first component going through (still involved in minimal way, waking up the other thread)

DEQ, allocations

message through system; too many datastructures and layers



== Control and Data Planes

main/main_process() in router/src/main.c
qd_dispatch_load_config(config file….)
python!
qd_router_setup_late() in src/router_node:
qdr_core() in src/router_core/router_core.c
spawns router_core_thread() src/router_core/router_core_thread.c
qd_server_run()
For each worker thread (+ main thread):
thread_run(qd_server….) in src/server.c
proactor main loop
src/server.c: all events
src/container.c: AMQP connection events


```
main/main_process() in router/src/main.c
qd_dispatch_load_config(config file….)
python!
qd_router_setup_late() in src/router_node:
qdr_core() in src/router_core/router_core.c
spawns router_core_thread() src/router_core/router_core_thread.c
qd_server_run()
For each worker thread (+ main thread):
thread_run(qd_server….) in src/server.c
proactor main loop
src/server.c: all events
src/container.c: AMQP connection events
```

== Startup sequence

* main/main_process() in router/src/main.c
   * qd_dispatch_load_config(config file….)
      * python!
          * qd_router_setup_late() in src/router_node:
               * qdr_core() in src/router_core/router_core.c
                    * spawns router_core_thread() src/router_core/router_core_thread.c
   * qd_server_run()
       * For each worker thread (+ main thread):
           * thread_run(qd_server….) in src/server.c
                * proactor main loop
                      * src/server.c: all events
                      * src/container.c: AMQP connection events

== Shutdown Sequence

See shutdown.adoc for a deeper dive

* signal_handler() router/src/main.c
   ** qd_server_stop()
      *** pn_proactor_interrupt(proactor)
          **** PN_PROACTOR_INTERRUPT in handle() in server.c
               ***** propagates to all proactor thread
               ***** sets running flag to break out of thread_run() server.c
               ***** thread_run() returns
* qd_server_run(): joins all worker threads to main thread, returns
* Back to main_process():
    ** qd_dispatch_free() (src/dispatch.c)
        *** qd_router_free() (src/router_node.c)
              **** qdr_core_free() (src/router_core/router_core.c)
                  ***** sets core->running = false (TODO: update this)
                  ***** joins router core thread

== Data plane: “gang of four”

A set of top-level singleton data structures:

* qd_dispatch_t - src/dispatch_private.h
   ** “top level” structure (?); initialized first
   ** references to qd_server_t, qd_container_t, qd_router_t
* qd_server_t - src/server.c
   ** references proactor
* qd_container_t - src/container.c
   ** “node” - AMQP event dispatch layer
* qd_router_t - src/router_private.h
   ** references router core (qdr_core_t)
   ** contains the “node” used by container.c

Future Architecture discussion topic: can we simplify this? Can this be more ‘adaptor like’?

== Data plane: AMQP handlers (dispatch library)

Interaction among:

* qd_server_t - proactor AMQP event batch handler
* qd_container_t - dispatches events to AMQP callbacks
   ** defines a set of callbacks to handler AMQP events
      *** qd_node_type_t in include/qpid/dispatch/container.h
   ** callbacks are the interface to the dispatch library “application”
* qd_router_t - router “application”
   ** registers callbacks with the container via a “qd_node_type_t”
   ** see the router_node structure in router_node.c

== Data plane: Proactor event handling

* The main proactor event loop in server.c::thread_run
   ** qd_server_t handles all events: listener, timer, interrupt, connection
* qd_server passes connection-related events to the container
   ** via qd_container_handle_event(container, event, pn_conn, qd_conn)
   ** only connection-related events, like session, link, delivery, flow, transport, wake
* qd_container_t - dispatches events to AMQP callbacks
   ** vectors these events into the qd_router_t callbacks
* AMQP_xxx functions defined in src/router_node.c

Note well: these are AMQP-specific events, NOT Raw Connection events!

Listener and Raw Conn event handling to be discussed in the future….

== Data plane: router_node.c - the AMQP “adaptor”

Router interacts with proton elements (pn_connection_t, links, deliveries)

“Safe” to touch proton stuff since it is running on a proactor thread (not core!)

Function call naming conventions:

* AMQP_xxx(): driven by incoming proactor events
   ** peer actions involving connections, links, deliveries, disposition, etc.
* CORE_xxx(): driven by router-generated work items
   ** local actions to be sent to the peer, e.g. send a new delivery, accept a link, etc.
   ** Uses the adaptor interface layer - see router_node.c::qd_router_setup_late()
   ** Kicked off by PN_CONNECTION_WAKE event
      *** EXCEPT CORE_connection_activate(_CT): called by core thread


== Data plane: the Adaptor interface

qdr_protocol_adaptor_t: abstraction to allow support of non-AMQP protocols

* used by router_core.c, http1, http2, tcp, etc…
* “fakes out” the router core: looks like an AMQP connection
* Associated with the router core’s connection object qdr_connection_t
* see qdr_protocol_adaptor() in include/qpid/dispatch/protocol_adaptor.h
   ** router-initiated protocol actions
      *** create an outgoing link, close a link, grant credit, send a delivery, set dispo, etc.
   ** qd_connection_activate callback: only callback run on CORE thread!
      *** schedules the I/O thread (pn_connection_wake(), the dreaded “timer zero”!)
      *** the rest are run on proactor threads

== Summary: Proactor AMQP Event Handlers

Proactor AMQP event handlers (src/router_node.c):

[source,c]
----
static qd_node_type_t router_node = {"router", 0, 0,
    AMQP_rx_handler,
    AMQP_disposition_handler,
    AMQP_incoming_link_handler,
    AMQP_outgoing_link_handler,
    AMQP_writable_conn_handler,
    AMQP_link_detach_handler,
    AMQP_link_attach_handler,
    qd_link_abandoned_deliveries_handler,
    AMQP_link_flow_handler, ...,
    AMQP_inbound_opened_handler,
    AMQP_outbound_opened_handler,
    AMQP_closed_handler};
----

== Summary: Adapter Interface

AMQP  (src/router_node.c):

[source,c]
----
qdr_protocol_adaptor(qd->router->router_core, "amqp", (void*) qd->router,
    CORE_connection_activate,
    CORE_link_first_attach,
    CORE_link_second_attach,
    CORE_link_detach,
    CORE_link_flow,
    CORE_link_offer,
    CORE_link_drained,
    CORE_link_drain,
    CORE_link_push,
    CORE_link_deliver,
    CORE_link_get_credit,
    CORE_delivery_update,
    CORE_close_connection,
    CORE_conn_trace);
----

AMQP Wiring
Connections, Links, Deliveries, Messages


Hierarchy

Global

qdr_connection_t
qdr_link_t
qdr_delivery_t
qd_message_t

AMQP Adaptor
qd_connection_t
qd_link_t

TCP Adaptor
qdr_tcp_connection_t

HTTP/2 Adaptor
qdr_http2_connection_t

HTTP/1 Adaptor
qdr_http1_connection_t


AMQP Connections

AMQP “Adaptor” specific: qd_connection_t

* src/server_private.h
* AMQP adaptor specific - not used by any other adaptor
* Created:
** pn_listener accept (incoming)
** Connector (outgoing)
* Proactor facing:
** pn_connection_t, pn_session_t(s), pn_ssl
* extensively used in router_node.c (AMQP_xxx)
* libWebsockets (router web console)

Router connection: qdr_connection_t
* src/router_core/router_core_private.h
* “abstract” connection representation
* Holds list of child links (qdr_link_t)
* work queue (qdr_connection_process())

constructor:

[source,c]
----
qdr_connection_t *qdr_connection_opened(qdr_core_t               	*core,
                                    	qdr_protocol_adaptor_t    	*protocol_adaptor,
                                    	bool                       	incoming,
                                    	qdr_connection_role_t      	role,
                                    	int                        	cost,
                                    	uint64_t                   	management_id,
                                    	const char                	*label,
                                    	const char                	*remote_container_id,
                                    	bool                       	strip_annotations_in,
                                    	bool                       	strip_annotations_out,
                                    	int                        	link_capacity,
                                    	const qd_policy_spec_t    	*policy_spec,
                                    	qdr_connection_info_t     	*connection_info,
                                    	qdr_connection_bind_context_t  context_binder,
                                    	void                      	*bind_token);
----

* qdr_connection_opened()
** include/qpid/dispatch/protocol_adaptor.h
** invoked on data-plane thread
*** router_node.c::AMQP_opened_handler()
*** other adaptors:
**** pn_listener accept handling (incoming)
**** locally initiated outgoing conn to server
*** sent via action to core thread - qdr_connection_opened_CT()
** teardown: qdr_connection_closed()
*** include/qpid/dispatch/protocol_adaptor.h
*** invoked on data-plane thread
**** adaptor “conn_close” handler for non-AMQP adaptors
**** in response to protocol close:
***** router_node.c::AMQP_closed_handler()
***** handling PN_RAW_CONNECTION_DISCONNECTED
*** sends action w/qdr_connection_closed_CT()

AMQP Links

* “Adaptor” specific: qd_link_t
** structure definition private to src/container.c
** AMQP adaptor specific - not used by any other adaptor
** Proactor facing:
*** pn_link_t, pn_session_t
** Created:
*** handling remote-initiated PN_LINK_REMOTE_OPEN
*** locally initiated via AMQP protocol adaptor “link first attach” handler
**** router_node.c::CORE_link_first_attach()
** Destroyed: qd_link_free()
*** router_core.c::AMQP_link_detach_handler()
*** locally initiated via AMQP protocol adaptor “link detach” handler
**** router_core.c::CORE_link_detach()

* Router link: qdr_link_t
** src/router_core/router_core_private.h
** “abstract” link representation
** Constructed:
*** router_core/connections.c::qdr_link_first_attach()
**** invoked by data plane thread
***** AMQP container callbacks:
****** router_node.c::AMQP_incoming/outgoing_link_handler()
**** sent via action to core - qdr_inbound_first_attach_CT()
*** locally initiated by control plane
**** qdr_create_link_CT()
** Destroyed:
*** router_core/connections.c::qdr_link_cleanup_CT()
**** in response to remote or locally initiated detach

** Holds list of active deliveries (qdr_delivery_t)
*** undelivered - forwarding not complete
*** unsettled - forwarded, pending settlement
*** settled - pre-settled but buffers not fully sent
*** updated - delivery state changed; need processing
** link work queue (qdr_connection_process())

AMQP Sessions

Not surfaced beyond the AMQP adaptor (src/container.c)

qdr_delivery_t

* Represents a message transfer
* src/router_core/delivery.h
* Used by all adaptors
** AMQP adaptor holds pn_delivery_t in user context field
** atomic reference counted
* 1-to-1 relationship with a qd_message_t
* Owned by parent qdr_link_t
* linked together as peers:
** 1 incoming
** 1..N outgoing (1 if unicast, else multicast)
** Or not… locally-generated outgoing messages (routing updates, mgmt, etc)
* local and remote delivery state
** outcome

qd_message_t  (src/message.c, src/message_private.h)

// TODO diagram, maybe use asciiart in source?

qd_message_t

* src/message.c and src/message_private.h
** message_private.h shared with unit test code
* include/qpid/dispatch/message.h public API
** qd_message()
** qd_message_free()
** qd_message_copy()
** …
* Uses a codec for parsing and composition
** parse.h and compose.h
** iterators!

Aside: qd_iterator_t

Iterators?

* demarcate a span of data in a qd_buffer_t chain
* starting buffer, offset, length in octets
* “view” - transform the underlying data based on context
** addresses and “node” identifiers (router id)
** hashing
** ITER_VIEW_ALL: no transformation, just raw data
* used to access data in messages
** message sections
** fields within sections
** example: qd_message_field_iterator(msg, QD_FIELD_REPLY_TO)
*** creates an iterator referencing the reply-to field in the Message Properties Section

qd_message_t

Created:

* `qd_message_receive()` - read from pn_link_t (AMQP only)
* locally generated (e.g. incoming from adaptor client)
** `qd_message_compose<_N>(... composed_fields,...)`
** `qd_message_extend(msg, composed_field, …)`
* Copied when forwarded (`qd_message_copy`)
** instantiates a new `qd_message_t`
** references the same `qd_message_content_t`  (ref_counted)
* Transmit
** `qd_message_send(msg, …)` written to `pn_link_t` (AMQP only)
** Adaptors directly access headers and body in data buffers:
*** e.g `src/adaptors/http1/http1_client.c::_encode_response_message()`
*** Access non-data sections via iterators
*** Body via a Stream Data API

AMQP Body Stream Data

* Provides support for managing data in streaming messages
* Used by Adaptors to generate/parse AMQP message body sections
** Adaptors put incoming client data into the AMQP message body section
** This is done in “chunks” of AMQP Body Data sections
** Why?  Total size is unknown upfront
* An iterator type API is provided to parse incoming AMQP message bodies
** qd_message_stream_data_t
** `qd_message_next_stream_data(msg, qd_message_stream_data_t *)`
** example: `http1_client.c::_encode_response_message()`

